<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ProbabilisticEchoInversion.jl</title><meta name="title" content="Home · ProbabilisticEchoInversion.jl"/><meta property="og:title" content="Home · ProbabilisticEchoInversion.jl"/><meta property="twitter:title" content="Home · ProbabilisticEchoInversion.jl"/><meta name="description" content="Documentation for ProbabilisticEchoInversion.jl."/><meta property="og:description" content="Documentation for ProbabilisticEchoInversion.jl."/><meta property="twitter:description" content="Documentation for ProbabilisticEchoInversion.jl."/><meta property="og:url" content="https://ElOceanografo.github.io/ProbabilisticEchoInversion.jl/"/><meta property="twitter:url" content="https://ElOceanografo.github.io/ProbabilisticEchoInversion.jl/"/><link rel="canonical" href="https://ElOceanografo.github.io/ProbabilisticEchoInversion.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ProbabilisticEchoInversion.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Tutorial"><span>Tutorial</span></a></li><li><a class="tocitem" href="#More-Advanced-Examples"><span>More Advanced Examples</span></a></li><li><a class="tocitem" href="#Using,-Citing,-and-Contributing"><span>Using, Citing, and Contributing</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ElOceanografo/ProbabilisticEchoInversion.jl/blob/main/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ProbabilisticEchoInversion.jl"><a class="docs-heading-anchor" href="#ProbabilisticEchoInversion.jl">ProbabilisticEchoInversion.jl</a><a id="ProbabilisticEchoInversion.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ProbabilisticEchoInversion.jl" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Welcome to the documentation for  <a href="https://github.com/ElOceanografo/ProbabilisticEchoInversion.jl">ProbabilisticEchoInversion</a>!</p><p>This package is designed to solve the &quot;inverse problem&quot; for acoustic backscatter at multiple frequencies in a Bayesian statistical framework. In other words, given observed  echoes from one or more types of scatterers, this package will help you infer</p><ol><li><strong>What</strong> they were,</li><li><strong>How many</strong> of them were present, and</li><li><strong>How sure</strong> you can be about (1) and (2). </li></ol><p>We call this approach Automatic Probabilistic Echo Solving, or APES.</p><p>This documentation provides a short introduction to the problem and general approach, as well as a simple tutorial on how to use the package. It assumes basic familiarity with the principles of fisheries acoustics and Bayesian statistical modeling (e.g. experience with Turing.jl, Stan, or JAGS). While the package is written in <a href="https://julialang.org/">Julia</a>, we don&#39;t assume prior Julia knowledge, and you should hopefully be able to follow along if you are familiar with scientific programming in a similar scripting language like R, Python, or Matlab.  Extensive resources for learning Julia are available at the <a href="https://julialang.org/learning/">official website</a>.</p><h3 id="Background"><a class="docs-heading-anchor" href="#Background">Background</a><a id="Background-1"></a><a class="docs-heading-anchor-permalink" href="#Background" title="Permalink"></a></h3><p>The typical approach in fisheries acoustics is to use relative differences in backscatter strength at multiple frequencies to classify parts of the water column as one thing or another (fish vs. zooplankton, large vs. small fish, etc.). These frequency responses are usually calculated by substracting backscatter at two different frequencies in the decibel domain  (&quot;dB differencing&quot;). Once the echogram has been classified using multifrequency information, scatterer density is estimated by echo-integrating at a single frequency, using the  relationship </p><p class="math-container">\[s_v = \langle \sigma_{bs} \rangle n,  \;\;\;\;\;\;(1)\]</p><p>where <span>$s_v$</span> is the volume backscattering coefficient, <span>$\langle \sigma_{bs} \rangle$</span> is the average backscattering cross section of a single scatterer, and <span>$n$</span> is their numerical density.</p><h3 id="The-Inverse-Approach"><a class="docs-heading-anchor" href="#The-Inverse-Approach">The Inverse Approach</a><a id="The-Inverse-Approach-1"></a><a class="docs-heading-anchor-permalink" href="#The-Inverse-Approach" title="Permalink"></a></h3><p>The inverse approach relies on the same theory and assumptions, but instead of classifying  first using multiple frequencies and then integrating using only one, it does both at the  same time, using all frequencies available. Mathematically, if we have a vector of  backscatter at multiple frequencies <span>$\mathbf{s}_v$</span>, and a matrix <span>$\Sigma$</span> of backscattering cross-sections, where the <span>$i,j^{th}$</span> entry holds <span>$\langle \sigma_{bs} \rangle$</span> for species <span>$j$</span> at frequency <span>$i$</span>, then solving the inverse problem means finding the vector of scatterer densities <span>$\mathbf{n} \ge 0$</span> that solves the equation </p><p class="math-container">\[\mathbf{s}_v = \Sigma \mathbf{n}. \;\;\;\;\;\;(2)\]</p><p>The inverse approach has several advantages over the classify-then-integrate approach:</p><ul><li>It uses all available frequency information to integrate, in theory giving a more robust estimate of animal density than single-frequency integration.</li><li>It extends naturally from a small number of narrowband frequencies to broadband spectra, or a mixture of the two.</li><li>It can handle mixtures of different scatterers, a situation where dB differencing struggles.</li></ul><p>However, even though the inverse approach has been around for some time, it has never acheived widespread use in practice, because Equation 2 is often (if not usually) underdetermined, and it involves inherent uncertainties that are nonlinear and  potentially difficult to quantify.</p><h3 id="Bayesian-Inverse-Modeling"><a class="docs-heading-anchor" href="#Bayesian-Inverse-Modeling">Bayesian Inverse Modeling</a><a id="Bayesian-Inverse-Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Bayesian-Inverse-Modeling" title="Permalink"></a></h3><p>One way to address these challenges is to implement the inverse problem as a Bayesian statistical model. Like all inversion methods, a Bayesian approach handles species mixtures, uses all available frequencies, and extends naturally to broadband signals. However, it has  a few distinct advantages. The priors required for a Bayesian model provide a rigorous way to incorporate assumptions, ecological knowledge, and/or data from direct  sampling. Good priors provide the inverse model with additional information, improving the quality of the solution and allowing even underdetermined problems to be solved. Bayesian models can incorporate multiple sources of uncertainty and propagate them through to the solution, increasing the robustness ofthe results: a well-specified  model should not produce solutions that are simultaneously wrong and confident. Finally, these models are based on physical scattering processes, so their output is fully interpretable, unlike some machine learning methods. Taken together, these  advantages make the inverse approach robust and reliable enough to be used on real-world acoustic data.</p><h2 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h2><h3 id="Installation-and-setup"><a class="docs-heading-anchor" href="#Installation-and-setup">Installation and setup</a><a id="Installation-and-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Installation-and-setup" title="Permalink"></a></h3><p>ProbabilisticEchoInversion.jl is a Julia package, so if you have not installed the Julia  programming language, that&#39;s the first thing to do. You can download the latest version for free from the <a href="https://julialang.org/downloads/">official website</a>. Even better, use the <a href="https://github.com/JuliaLang/juliaup">Juliaup installer/version manager</a>, which  makes it much easier to upgrade when new Julia versions are released.</p><p>You can work with Julia files in any text editor, but for a nice integrated experience, we can recommend <a href="https://code.visualstudio.com/">Visual Studio Code</a> with the  <a href="https://www.julia-vscode.org/">Julia extension</a>, <a href="https://jupyter.org/">Jupyter</a>, or  <a href="https://plutojl.org/">Pluto</a>.</p><p>Once you have Julia installed, open the Julia command line (a.k.a. the read-evaluate-print-loop, or REPL). While not required, it is easy and highly recommended to set up a local environment  for each of your projects. To do that for this tutorial, run the following commands:</p><pre><code class="language-julia-repl hljs"># create a new folder--could call it whatever you want
julia&gt; mkdir(&quot;APESTutorial&quot;)

# change directory to the folder we just created
julia&gt; cd(&quot;APESTutorial&quot;)

# type `]` to enter package manager mode
julia&gt; ]

# activate the current directory as project environment
(@v1.9) pkg&gt; activate .

(APESTutorial) pkg&gt;</code></pre><p>Install the package to this new project environment by running the following command:</p><pre><code class="language-julia-repl hljs">(APESTutorial) pkg&gt; add ProbabilisticEchoInversion</code></pre><p>To recreate the graphics, install Plots.jl and ColorSchemes.jl the same way:</p><pre><code class="language-julia-repl hljs">(APESTutorial) pkg&gt; add Plots ColorSchemes</code></pre><blockquote><p><strong>Note</strong> <strong>: Using local environments</strong></p><p>You don&#39;t strictly need to create a local environment, and can install ProbabilisticEchoInversion into the top-level Julia environment (i.e., <code>(@v1.9)</code> instead of <code>APESTutorial</code>). This will make it vailable automatically for all projects. However, the more packages you install in the top-level environment, the more likely you are to end up with conflicting versions and dependencies. In our experience, working with local environments is <em>much</em> easier in the long run–and as a pleasant side effect, it makes it much easier to reproduce your analyses, since all the precise package versions you used are recorded automatically in the Project.toml and Manifest.toml files.</p></blockquote><p>Once everything has downloaded and precompiled, you can exit the package manager by hitting backspace. To run the rest of this tutorial yourself, you&#39;ll need the data files located <a href="https://github.com/ElOceanografo/ProbabilisticEchoInversion.jl/tree/main/examples">here</a>. Download them to the project directory you just created. You can also download the <code>example.jl</code> script, which contains all the following code in one place.</p><h3 id="Loading-and-arranging-your-data"><a class="docs-heading-anchor" href="#Loading-and-arranging-your-data">Loading and arranging your data</a><a id="Loading-and-arranging-your-data-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-and-arranging-your-data" title="Permalink"></a></h3><p>ProbabilisticEchoInversion expects your acoustic data to be arranged in a multidimensional <code>DimArray</code> from DimensionalData.jl. <code>DimArray</code>s behave like normal Julia arrays, but also  let you index with named dimensions and have a bunch of nice functionality for subsetting, slicing, and plotting. For a typical downard-looking echosounder on a moving ship, your  data have three dimensions - depth, distance, and frequency - meaning this array will be  three-dimensional.</p><p>If your data are already stored this way, for instance in a NetCDF or .mat file, it will be easy to convert them to a <code>DimArray</code> (refer to the <a href="https://rafaqz.github.io/DimensionalData.jl/stable/course/">DimensionalData.jl documentation</a> for details). If your data are stored as a table in &quot;long&quot; format, as is typical for .CSV exports from Echoview, you will need to do some reshaping first. This package provides a function <code>unstack_echogram</code> to take care of that reshaping.</p><p>First, load the required packages.</p><pre><code class="language-julia hljs">using ProbabilisticEchoInversion
using CSV, DataFrames
using DimensionalData, DimensionalData.Dimensions</code></pre><p>This tutorial contains five comma-delimited data files, one for each frequency. We read them in, add a <code>frequency</code> column to each one, and use <code>vcat</code> to stack them all into a single <code>DataFrame</code>.</p><pre><code class="language-julia hljs">freqs = [18, 38, 70, 120, 200]
echo_df = map(freqs) do f
    filename = joinpath(@__DIR__, &quot;DY1702_haul24_$(f)kHz.csv&quot;)
    df = CSV.read(filename, DataFrame)
    df[!, :frequency] .= f
    return df
end
echo_df = vcat(echo_df...)</code></pre><p>Next, we&#39;ll transform this data frame into a 3-d <code>DimArray</code>. The <code>unstack_echogram</code> function takes long-format a <code>DataFrame</code> as its first argument. That <code>DataFrame</code> needs to have at least four columns:</p><ol><li>An x-coordinate, such as along-track distance or time</li><li>A y-coordinate, such as depth or range from the transducer</li><li>Acoustic frequency, and</li><li>Acoustic mean volume backscatter (can be in linear or decibel units )</li></ol><p>The names of these columns are passed to <code>unstack_echogram</code> as the second through fifth arguments, respectively. In this example, the data files are standard .csv exports from Echoview, and the relevant column names are:</p><pre><code class="language-julia hljs">echo = unstack_echogram(echo_df, :Dist_M, :Layer_depth_min, :frequency, :Sv_mean)</code></pre><p>By default, the axes of <code>echo</code> will be named <code>X</code>, <code>Y</code>, and <code>F</code>. If you&#39;d like to  define your own dimensions, this is easy to do with the <code>@dim</code> macro from <code>DimensionalData.Dimensions</code>. You can then supply them in the optional final three arguments to <code>unstack_echogram</code> and they will be applied to the  <code>DimArray</code> it returns.</p><pre><code class="language-julia hljs">@dim Z YDim &quot;Depth (m)&quot;
@dim D XDim &quot;Distance (km)&quot;
echo = unstack_echogram(echo_df, :Dist_M, :Layer_depth_min, :frequency, :Sv_mean, D, Z)</code></pre><p>It is now easy to manipulate the multifrequency echogram, for instance by selecting a  slice by frequency and plotting it. Refer to the DimensionalData.jl docs to learn more about how to slice and dice <code>DimArrays</code>.</p><pre><code class="language-julia hljs">heatmap(echo[F(At(120))], yflip=true)</code></pre><p><img src="https://github.com/ElOceanografo/ProbabilisticEchoInversion.jl/blob/main/examples/echogram.png?raw=true" alt="Echogram of example data at 120 kHz"/></p><h3 id="Defining-the-model"><a class="docs-heading-anchor" href="#Defining-the-model">Defining the model</a><a id="Defining-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-model" title="Permalink"></a></h3><p>Once the data are loaded in, we need to define the inverse model we want to solve. This is done using the probabilistic programming language Turing.jl. If you are familiar with BUGS, JAGS, or Stan, model definitions in Turing are conceptually very similar. If  you have not worked with it before, it is worth studying the Turing  <a href="https://turinglang.org/dev/docs/using-turing/get-started">documentation</a> before going any further.</p><p>A very simple inverse model is defined below.</p><pre><code class="language-julia hljs">@model function examplemodel(data, params)
    nfreq, nspp = size(params.TS)
    Σ = exp10.(params.TS ./ 10)

    # define priors
    logn ~ arraydist(Normal.(zeros(nspp), fill(3, nspp))) # scatterer log-densities
    ϵ ~ Exponential(1.0) # observation error variance

    # Predict Sv based on scatterer density and TS
    n = exp10.(logn)
    μ = 10log10.(Σ * n)

    # Compare observed to predicted backscatter
    data.backscatter .~ Normal.(μ, fill(ϵ, nfreq))
end</code></pre><p>To work with APES, your model function must take two arguments. The first, <code>data</code>, is a <code>NamedTuple</code> containing acoustic data and metadata from a single cell. These data tuples will be generated automatically when you run the analysis using the <code>apes</code> function (described below), and will contain three fields, all accessible using dot-notation:</p><ul><li><code>data.backscatter</code> : Vector of backscatter values (in whatever units you defined your <code>echo</code> array)</li><li><code>data.freqs</code> : Vector of frequencies at which <code>backscatter</code> was recorded</li><li><code>data.coords</code> : Spatial/temporal coordinates of the cell within the <code>echo</code> array, as a <code>NamedTuple</code> with values for the (non-frequency) dimensions of the echogram.  In this tutorial, the echogram has depth and distance dimensions named <code>Z</code> and <code>D</code>, so <code>data.coords</code> would be something like e.g. <code>(Z = 120.0, D = 6.5)</code>, indicating that <code>data.backscatter</code> was recorded at a depth of 120 m, 6.5 km along the ship&#39;s track.</li></ul><p>You can use any of these fields inside the model, but <code>data.backscatter</code> is the only one  you <em>must</em> use, since it contains the actual observations. The frequencies and coordinates may be useful in more complex models where you want the priors or TS values to vary with depth or location.</p><p>The second argument, <code>params</code> is for any constants or auxiliary information you want to pass to the model. It will typically be a <code>NamedTuple</code>, but can be any data type you want. If your model doesn&#39;t need any other info, just supply an empty tuple <code>()</code>.  Here, we&#39;ll use <code>params</code> to hold a single item, a matrix of target strengths (TS).</p><p>This model assumes a fixed number of scattering classes are present, each with a known TS spectrum. It puts a vague prior on their log-densities, and assumes a single error variance for all frequencies. </p><blockquote><p><strong>Note</strong> <strong>: Writing models in the log-domain</strong></p><p>Note that this model is defined in the logarithmic domain - that is, the scatterer densities are written as log-densities, and the observed data are assumed to be decibel-valued mean volume backscattering strengths (<span>$S_v$</span>) instead of linear mean volume backscattering coefficients (<span>$s_v$</span>). While not strictly required, defining your models this way is a <em>really good idea</em>. The small absolute values and wide ranges of both scatterer densities and observed backscatter means that linear-domain models often have problems with floating-point precision that can manifest in inefficient and/or incorrect inference.</p></blockquote><p>The last step in setting up our model is to choose our candidate scatterers and construct the TS matrix. A research trawl performed at this location found a mixture of Alaska pollock (<em>Gadus chalcogrammus</em>), unidentified lanternfish, and Pacific glass shrimp (<em>Pasiphaea pacifica</em>). We will assume these were the main scatterers present and define three plausible TS spectra at our five frequencies. We then concatenate them into a matrix and wrap it in a named tuple.</p><pre><code class="language-julia hljs">TS_pollock = [-34.6, -35.0, -35.6, -36.6, -38.5]
TS_myctophid = [-73.0, -58.0, -65, -67.2, -70.0]
TS_shrimp = [-100, -90, -82, -76.2, -73.7]
TS = [TS_pollock TS_myctophid TS_shrimp]
params = (; TS)

plot(freqs, TS, marker=:o, label=[&quot;Pollock&quot; &quot;Myctophid&quot; &quot;Shrimp&quot;],
    xlabel=&quot;Frequency (kHz)&quot;, ylabel=&quot;TS (dB re m⁻²)&quot;)</code></pre><p><img src="https://github.com/ElOceanografo/ProbabilisticEchoInversion.jl/blob/main/examples/ts.png?raw=true" alt="TS spectra of pollock, myctophids, and shrimp"/></p><h3 id="Running-the-model"><a class="docs-heading-anchor" href="#Running-the-model">Running the model</a><a id="Running-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-model" title="Permalink"></a></h3><p>Once the data, parameters, and model are all set up, running it is just one line of code.</p><pre><code class="language-julia hljs">solution_mcmc = apes(echo, examplemodel, MCMCSolver(), params=params)</code></pre><p>This will draw 1,000 samples from the joint posterior of the model for each acoustic cell, using the No-U-Turn Sampler (NUTS) from Turing. Any cells where all backscatter values are <code>missing</code> (e.g., below-bottom cells) will be skipped. Altogether, the inference will take on the order of 5-20 minutes to finish, depending on your machine.</p><p>If you don&#39;t have time to wait for (asymptotically) exact inference, you can opt for a much faster option: maximum-a-posteriori optimization, with errors estimated via the delta method. This is done by changing the solver argument to <code>MAPSolver()</code>. Inference in this case takes just a few seconds.</p><pre><code class="language-julia hljs">solution_map = apes(echo, examplemodel, MAPSolver(), params=params)</code></pre><p>In either case (MCMC chains or optimization fits) the results are returned in a <code>DimArray</code> that shares the first two dimensions as <code>echo</code>, so they are also easy to manipulate and  plot. For instance, arrays of posterior means and standard deviations can be obtained this way,</p><pre><code class="language-julia hljs">post_mean = passmissing(chn -&gt; mean(Array(chn), dims=2)).(solution_mcmc);
post_cv = passmissing(chn -&gt; cv(Array(chn), dims=2)).(solution_mcmc);</code></pre><p>where we use <code>passmissing</code> to deal with the fact that some of the result cells contain MCMC chains and some are missing.</p><h2 id="More-Advanced-Examples"><a class="docs-heading-anchor" href="#More-Advanced-Examples">More Advanced Examples</a><a id="More-Advanced-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#More-Advanced-Examples" title="Permalink"></a></h2><p>Because the inverse model is defined in Turing.jl&#39;s modeling language, APES is incredibly flexible in terms of the data and situations to which it can be applied. For a more in- depth look at some of its capabilities, please check out the fully-worked example  problems in the <a href="https://github.com/ElOceanografo/APESExamples">APESExamples repository</a>. These reproduce the analyses and figures in Urmy et al. 20**, and include:</p><ul><li>A simulated fish/zooplankton mixture, demonstrating how to solve simultaneously for scatterer size and density,</li><li>A simulated mesopelagic scattering layer, demonstrating how to use ground-truth data to constrain the solution of an underdetermined inverse problem,</li><li>An application of APES to a variety of mixed scattering types at the Aleutian shelfbreak</li></ul><p>in the Gulf of Alaska, </p><ul><li>And an application of APES to broadband backscatter from zooplankton and fish of mixed </li></ul><p>sizes in Barnabas Trough, south of Kodiak Island.</p><h2 id="Using,-Citing,-and-Contributing"><a class="docs-heading-anchor" href="#Using,-Citing,-and-Contributing">Using, Citing, and Contributing</a><a id="Using,-Citing,-and-Contributing-1"></a><a class="docs-heading-anchor-permalink" href="#Using,-Citing,-and-Contributing" title="Permalink"></a></h2><p>This software was developed by Sam Urmy at NOAA&#39;s Alaska Fisheries Science Center. As a  product of the U.S. Government, it is free for anyone to use under a public-domain Creative Commons CC0 license. </p><p>ProbabilisticEchoInversion.jl has been tested and peer-reviewed, but should still be considered research-grade beta software rather than fully production-ready. If you try  it on your own data, please do submit bug reports, comments, and feature requests via the project&#39;s <a href="https://github.com/ElOceanografo/ProbabilisticEchoInversion.jl">GitHub repository</a>. Pull requests are welcome, both for code and documentation!</p><p>Finally, if you do use APES in your own work, please cite the following publication:</p><p>Urmy, De Robertis, and Bassett (2023). A Bayesian inverse approach to identify and quantify organisms from fisheries acoustic data. <em>ICES Journal of Marine Science</em>,  https://doi.org/10.1093/icesjms/fsad102</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><ul><li><a href="#ProbabilisticEchoInversion.MAPMCMCSolver"><code>ProbabilisticEchoInversion.MAPMCMCSolver</code></a></li><li><a href="#ProbabilisticEchoInversion.MAPSolver"><code>ProbabilisticEchoInversion.MAPSolver</code></a></li><li><a href="#ProbabilisticEchoInversion.MCMCSolver"><code>ProbabilisticEchoInversion.MCMCSolver</code></a></li><li><a href="#ProbabilisticEchoInversion.apes-Tuple{DimensionalData.DimArray, Function, AbstractSolver}"><code>ProbabilisticEchoInversion.apes</code></a></li><li><a href="#ProbabilisticEchoInversion.iterspectra"><code>ProbabilisticEchoInversion.iterspectra</code></a></li><li><a href="#ProbabilisticEchoInversion.mapspectra-Tuple{Any, DimensionalData.DimArray}"><code>ProbabilisticEchoInversion.mapspectra</code></a></li><li><a href="#ProbabilisticEchoInversion.solve"><code>ProbabilisticEchoInversion.solve</code></a></li><li><a href="#ProbabilisticEchoInversion.unstack_echogram"><code>ProbabilisticEchoInversion.unstack_echogram</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProbabilisticEchoInversion.MAPMCMCSolver" href="#ProbabilisticEchoInversion.MAPMCMCSolver"><code>ProbabilisticEchoInversion.MAPMCMCSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MAPMCMCSolver([;optimizer, options])</code></pre><p>Construct an <code>MAPMCMCSolver</code>, specifying how to invert a probabilistic backscattering model using a combination of maximum a posteriori optimization and Markov-chain Monte  Carlo. This simply means that an optimization routine finds the MAP point estimate of the parameters, which is then used as the starting point for the MCMC run.</p><p>Arguments correspond exactly to the ones for <code>MAPSolver</code> and <code>MCMCSolver</code>; refer to  their documentation for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ElOceanografo/ProbabilisticEchoInversion.jl/blob/f95065a73d4b5ea90cc57f96ff34f463377fb471/src/ProbabilisticEchoInversion.jl#L75-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProbabilisticEchoInversion.MAPSolver" href="#ProbabilisticEchoInversion.MAPSolver"><code>ProbabilisticEchoInversion.MAPSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MAPSolver([;optimizer, options])</code></pre><p>Construct a <code>MAPSolver</code>, specifying how to invert a probabilistic backsattering model using maximum a-posteriori optimization.  Default optimizer is LBFGS. See Turing.jl and Optim.jl documentation for more information on available solvers and options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ElOceanografo/ProbabilisticEchoInversion.jl/blob/f95065a73d4b5ea90cc57f96ff34f463377fb471/src/ProbabilisticEchoInversion.jl#L52-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProbabilisticEchoInversion.MCMCSolver" href="#ProbabilisticEchoInversion.MCMCSolver"><code>ProbabilisticEchoInversion.MCMCSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MCMCSolver([;sampler, parallel, nsamples, nchains; kwargs, verbose])</code></pre><p>Construct an <code>MCMCSolver</code>, specifying how to invert a probabilistic backscattering model using Markov-chain Monte Carlo. By default uses the no-U-turn sampler with  acceptance rate 0.8 and collects 1000 samples. See Turing.jl documentation for more information on options for MCMC sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ElOceanografo/ProbabilisticEchoInversion.jl/blob/f95065a73d4b5ea90cc57f96ff34f463377fb471/src/ProbabilisticEchoInversion.jl#L34-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProbabilisticEchoInversion.apes-Tuple{DimensionalData.DimArray, Function, AbstractSolver}" href="#ProbabilisticEchoInversion.apes-Tuple{DimensionalData.DimArray, Function, AbstractSolver}"><code>ProbabilisticEchoInversion.apes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apes(echogram, model, solver[; params, result_handler, safe_precision, distributed])</code></pre><p>Run the automatic probabilistic echo solver defined by the inverse <code>model</code> and  solution method <code>solver</code> on the acoustic backstter data in <code>echogram</code>.</p><p><strong>Arguments</strong></p><ul><li><code>echogram::DimArray</code>: Acoustic backscatter data in the linear domain (i.e.,   volume backsattering coefficient <span>$s_v$</span>, area backsattering coefficient <span>$s_a$</span>,   or nautical area scattering coefficient, <span>$NASC$</span>). The last dimension of    the <code>DimArray</code> should be named <code>:F</code> and index the acoustic frequencies;    all other dimensions should reference spatial/temporal coordinates.</li><li><code>model::Function</code>: Probabilistic inverse model defined with Turing.jl   or DynamicPPL.jl. This model should have the signature <code>model(data, params)</code>,   where <code>data</code> and <code>params</code> contain the acoustic data and any additional   parameters. See below for more details.</li><li><code>solver::AbstractSolver</code>: The method used to solve the inverse problem   specified in <code>model</code>. See <code>MCMCSolver</code> and <code>MAPSolver</code> for more detail.</li><li><code>params</code>: Optional additional params to pass to <code>model</code>.</li><li><code>result_handler</code>: Optional function to transform the output of the solver    before (for instance, by calculating the means of a Markov chain).</li><li><code>distributed::Bool=false</code>: Whether to use all available processors when    fitting model to echogram cells.</li></ul><p><strong>Details</strong></p><p>This function applies a probabilistic inverse backscattering model defined using Turing.jl to each spectrum in a mulifrequency echogram. The model&#39;s constructor must accept two arguments:</p><ul><li><code>data</code>: A <code>NamedTuple</code> or other structure accessible by dot-notation, with   fields <code>coords</code>, <code>freqs</code>, and <code>backscatter</code>. These contain the observed   acoustic data. The model doesn&#39;t have to use all of them.</li><li><code>params</code>: Optional <code>NamedTuple</code> or other object, containing any constants or   auxiliary information used by the model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ElOceanografo/ProbabilisticEchoInversion.jl/blob/f95065a73d4b5ea90cc57f96ff34f463377fb471/src/ProbabilisticEchoInversion.jl#L245-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProbabilisticEchoInversion.iterspectra" href="#ProbabilisticEchoInversion.iterspectra"><code>ProbabilisticEchoInversion.iterspectra</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iterspectra(echogram[, freqdim])</code></pre><p>Given an mulifrequency or broadband echogram in the form of a <code>DimArray</code>, with the acoustic frequencies in one dimension (by default named <code>:F</code>), iterate over each spectrum. The iterator yields <code>NamedTuples</code> with three fields: </p><ul><li><code>coords</code>: Coordinates of the spectrum on the non-<code>:F</code> dimensions of the Array   (i.e. its location space/time)</li><li><code>freqs</code>: Array of acoustic frequencies</li><li><code>backscatter</code>: Array of backscatter values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ElOceanografo/ProbabilisticEchoInversion.jl/blob/f95065a73d4b5ea90cc57f96ff34f463377fb471/src/ProbabilisticEchoInversion.jl#L200-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProbabilisticEchoInversion.mapspectra-Tuple{Any, DimensionalData.DimArray}" href="#ProbabilisticEchoInversion.mapspectra-Tuple{Any, DimensionalData.DimArray}"><code>ProbabilisticEchoInversion.mapspectra</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mapspectra(f, echogram[; freqdim, distributed])</code></pre><p>Map the function <code>f</code> over each spectrum in the <code>DimArray</code> <code>echogram</code>. By default assumes the acoustic frequencies are recorded in dimension <code>:F</code>, if this is not the case, specify the name of the dimension using the <code>freqdim</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ElOceanografo/ProbabilisticEchoInversion.jl/blob/f95065a73d4b5ea90cc57f96ff34f463377fb471/src/ProbabilisticEchoInversion.jl#L227-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProbabilisticEchoInversion.solve" href="#ProbabilisticEchoInversion.solve"><code>ProbabilisticEchoInversion.solve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve(data, model, solver[, params])</code></pre><p>Run the probabilistic inverse model defined by <code>model</code> on the acoustic backscatter spectrum in <code>data</code>, using <code>solver</code> as the inference engine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ElOceanografo/ProbabilisticEchoInversion.jl/blob/f95065a73d4b5ea90cc57f96ff34f463377fb471/src/ProbabilisticEchoInversion.jl#L98-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProbabilisticEchoInversion.unstack_echogram" href="#ProbabilisticEchoInversion.unstack_echogram"><code>ProbabilisticEchoInversion.unstack_echogram</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unstack_echogram(echo_df, xcol, ycol, fcol, svcol[, X, Y, F])</code></pre><p>Convert a long-format <code>DataFrame</code> of multifrequency acoustic data into a three-dimensional <code>DimArray</code> representing an echogram. This <code>DataFrame</code> must contain the following columns:</p><ol><li>An x-coordinate, such as along-track distance or time</li><li>A y-coordinate, such as depth or range from the transducer</li><li>Acoustic frequency, and</li><li>Acoustic mean volume backscatter (can be in linear or decibel units )</li></ol><p>The names of these columns are passed to <code>unstack_echogram</code> as the second through fifth arguments, respectively.</p><ul><li><code>echo_df::DataFrame</code> : Long-format <code>DataFrame</code> with columns for an x and y coordinate,</li></ul><p>acoustic frequency, and backscatter.</p><ul><li><code>xcol</code>, <code>ycol</code>, <code>fcol</code>, <code>svcol</code> : Names of the columns in <code>echo_df</code> (as <code>Symbol</code>s)</li><li><code>X</code>, <code>Y</code>, <code>F</code> : Optional <code>Dimensions</code> to apply to the x, y, and frequency axes of the </li></ul><p>resulting <code>DimArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ElOceanografo/ProbabilisticEchoInversion.jl/blob/f95065a73d4b5ea90cc57f96ff34f463377fb471/src/ProbabilisticEchoInversion.jl#L293-L313">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 19 August 2025 23:12">Tuesday 19 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
